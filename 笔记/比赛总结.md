# 牛客周赛
### 周赛103
#### 应该补的题目

##### [E-新婚_牛客周赛 Round 103](https://ac.nowcoder.com/acm/contest/114593/E)
##### 题目大意
给定一颗树，每个节点有一个二进制的值，让你找到从一个祖先到他的孩子的点**也可以相反** 如果是相同就不行
如图1-3或者3-1是可一个，2-3就不行，lca为最近公共祖先
![[Pasted image 20250804153246.png]]

让你求出所有符合条件的u-v这样的二进制的值，同时给定询问看是否存在这样的值
##### 题目主要实现思路
首先观察数据范围为2的20次方，一个节点代表一个二进制位树，所以最多遍历20个节点，相当于只用计算长度小于等于20的路径遍历整个树，并且记录每一个节点的父节点，回溯时，依次计算，每一个二进制值，
```c++
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 1e6 + 10;

int f[N];

int btoi(string s)

{

    int res = 0;

    for (int i = s.size() - 1; i >= 0; i--)

    {

        res = res * 2 + (s[i] - '0');

    }

    return res;

}

void solve()

{

    int n, q;

    cin >> n >> q;

    string s;

    cin >> s;

    vector<vector<int>> adj(n);

    for (int i = 0; i < n - 1; i++)

    {

        int a, b;

        cin >> a >> b;

        a--;

        b--;

        adj[a].push_back(b);

        adj[b].push_back(a);

    }

    vector<int> vit(1 << 21, 0);

    auto dfs = [&](auto &&self, int u, int fa) -> void

    {

        f[u] = fa;

        for (int nu : adj[u])

        {

            if (nu != fa)

            {

                self(self, nu, u);

            }

        }

        int nw = u, stp = 0;

        string tps;

        while (nw >= 0 && stp <= 20)

        {

            tps += s[nw];

            string tp(tps);

            reverse(tp.begin(), tp.end());

            vit[btoi(tps.c_str())] = 1;

            vit[btoi(tp.c_str())] = 1;

            stp++;

            nw = f[nw];

        }

    };

    dfs(dfs, 0, -1);

    while (q--)

    {

        int x;

        cin >> x;

        if (vit[x])

        {

            cout << "YES" << '\n';

        }

        else

        {

            cout << "NO" << '\n';

        }

    }

}

  

signed main()

{

    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

    int T;

    T = 1;

    //  cin >> T;

    while (T--)

    {

        solve();

    }

    return 0;

}
```







# atcoder

### abc417
#### 应该补的题目
##### D - Takahashi's Expectation
[D - Takahashi's Expectation](https://atcoder.jp/contests/abc417/tasks/abc417_d)
##### 题目大意（自己总结）
有n份礼物，价值p,心情上升a,心情下降b，如果收到礼物价值大于p或者等于 心情加上a,如果小于p心情降低B,给定q个问题，初始心情为x求出收到所有礼物后的心情
- 1≤N≤10000
- 1≤Pi​≤500 (1≤i≤N)
- 1≤Ai​≤500 (1≤i≤N)
- 1≤Bi​≤500 (1≤i≤N)
- 1≤Q≤5×105
- 0≤Xi​≤109 (1≤i≤Q)
- All input values are integers.
##### 题目主要实现思路
首先观察数据范围，特别小，而x的范围特别大，可以通过小范围的dp，定义状态dp【 i】[  j ] 等于收完第i个礼物之后的心情值，因为要求最终结果，可以着推，对于每一次询问的x，如果x过于大，最后肯定会一直减，x如果大于pre[ n ]
最后结果一定是x-所有n的和，如果x一直减到一个地方小于500，那就可以直接dp求出最后的结果
```c++
#include <bits/stdc++.h>

using namespace std;

#define int long long

const int N = 1e6 + 10;

struct pa

{

    int p, a, b;

};

pa g[N];

int pre[N];

void solve()

{

    int n;

    cin >> n;

    for (int i = 1; i <= n; i++)

    {

        cin >> g[i].p >> g[i].a >> g[i].b;

        pre[i] = pre[i - 1] + g[i].b;

    }

    vector<vector<int>> dp(n + 2, vector<int>(1010, 0)); // 第i个礼物之后的心情值

    for (int i = 0; i < 1010; i++)

    {

        dp[n + 1][i] = i;

    }

    for (int i = n; i > 0; i--)

    {

        for (int j = 0; j < 1010; j++)

        {

            if (j > g[i].p)

            {

                dp[i][j] = dp[i + 1][max(0LL, j - g[i].b)]; //当前状态经过这一操作后到达下一状态

            }

            else

            {

                dp[i][j] = dp[i + 1][j + g[i].a];

            }

        }

    }

    int q;

    cin >> q;

    while (q--)

    {

        int x;

        cin >> x;

        int pos = lower_bound(pre + 1, pre + 1 + n, x - 500) - pre;//判断什么时候减到小于500

        if (pos == n + 1)

        {

            cout << x - pre[n] << '\n';

        }

        else

        {

            cout << dp[pos][x - pre[pos-1]] << '\n';

        }

    }

}

  

signed main()

{

    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

    int T;

    T = 1;

    // cin >> T;

    while (T--)

    {

        solve();

    }

    return 0;

}
```

##### E - A Path in A Dictionary
[E - A Path in A Dictionary](https://atcoder.jp/contests/abc417/tasks/abc417_e)
##### 题目大意（自己总结）
给你一个图，让你找到从一个点到另一个点的路径边最小，最小定义为整数序列的词法顺序 如果下列 1. 或 2. 中的任一个成立，则整数序列 S=(S1​,S2​,…,S∣S∣​) 在词法上小于整数序列 T=(T1​,T2​,…,T∣T∣​) 。这里， ∣S∣ 和 ∣T∣ 分别表示 S 和 T 的长度。
∣S∣<∣T∣ 和 (S1​,S2​,…,S∣S∣​)=(T1​,T2​,…,T∣S∣​) 。
存在一些 1≤i≤min(∣S∣,∣T∣) 使得 (S1​,S2​,…,Si−1​)=(T1​,T2​,…,Ti−1​) 和 Si​<Ti​ .
因为x-y路径起点终点一定相等，所以第一种不可能出现，所以尽可能选择最小的点，对与每一个边排序即可，有可能所有选最小的都到不了，所以按边排序dfs即可

##### 题目主要实现思路
```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e6 + 10;

void solve()
{
    vector<int> ans;
    int n, m, x, y;
    cin >> n >> m >> x >> y;
    x--;
    y--;
    vector<vector<int>> adj(n);
    for (int i = 0; i < m; i++)
    {
        int a, b;
        cin >> a >> b;
        a--;
        b--;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    for(auto &it:adj)
    {
        sort(it.begin(),it.end());
    }
    vector<int> vit(n);
    auto dfs = [&](auto &&self, int u, int ed) -> void
    {
        vit[u] = 1;
      if(ed==u)
      {
       
        for(auto it:ans)
        {
            cout<<it+1<<' ';
        }
        cout<<'\n';
        return ;
      }
        for (auto nu : adj[u])
        {
            if (!vit[nu])
            {
                ans.push_back(nu);
                self(self,nu,ed);
                ans.pop_back();
            }
        }
       
    };
    ans.push_back(x);
    dfs(dfs,x,y);
    
}

signed main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T;
    T = 1;
    cin >> T;
    while (T--)
    {
        solve();
    }
    return 0;
}
```


#### 赛后总结






# codeforces
